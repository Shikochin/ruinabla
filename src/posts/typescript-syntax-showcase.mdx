---
title: TypeScript Syntax Showcase
date: '2022-02-06'
tags:
  - TypeScript
summary: >-
  这是一份全面的TypeScript语法特性展示文件。文章通过代码示例，系统地介绍了其核心功能，包括基础类型、接口、类、泛型、模块，以及映射类型、条件类型等高级用法。
readingMinutes: 1
---

Test twoslash if it works properly.

Here is a file that shows off the syntax highlighting and twoslash. Generated by Gemini 3 Pro.

```ts
/**
 * TypeScript 语法特性展示文件
 * 包含核心类型、类、接口、泛型、枚举、模块等主要特性。
 */

// =================================================================
// 1. 基础类型与类型推断 (Basic Types and Type Inference)
// =================================================================

const isDone: boolean = true
const decimal: number = 255
const hex: number = 0xff
const myName: string = 'Alice'

// 数组
const list: number[] = [1, 2, 3]
const genericList: Array<string> = ['a', 'b', 'c']

// 元组 (Tuple): 严格限定元素数量和类型的数组
let x: [string, number]
x = ['hello', 10] // OK
// x = [10, "hello"]; // Error

// 枚举 (Enum): 默认从 0 开始编号
enum Color {
  Red, // 0
  Green, // 1
  Blue, // 2
}
let c: Color = Color.Green
const colorName: string = Color[2] // "Blue"

// Any & Unknown:
let notSure: any = 4 // 允许任何操作，放弃类型检查
let value: unknown = 'Maybe a string' // 类型安全版的 any，需要类型检查才能使用

// Void, Null, Undefined
function warnUser(): void {
  console.log('This function returns nothing')
}
let u: undefined = undefined
let n: null = null

// Never: 永远不会返回的类型 (例如抛出异常或无限循环)
function error(message: string): never {
  throw new Error(message)
}

// =================================================================
// 2. 联合类型与交叉类型 (Union & Intersection Types)
// =================================================================

// 联合类型 (Union): 允许变量是多种类型之一
type StringOrNumber = string | number
let valueU: StringOrNumber = 42
valueU = 'forty-two'

// 交叉类型 (Intersection): 组合多个类型为一个新类型
interface A {
  a: number
}
interface B {
  b: string
}
type AB = A & B
const combined: AB = { a: 1, b: 'two' }

// =================================================================
// 3. 接口 (Interfaces)
// =================================================================

interface Point {
  readonly x: number // 只读属性
  y: number
  z?: number // 可选属性
  [propName: string]: any // 索引签名：允许其他任意字符串属性
}

function printPoint(p: Point) {
  console.log(`(${p.x}, ${p.y})`)
}

const myPoint: Point = { x: 10, y: 20, label: 'start' }

// 函数类型接口
interface SearchFunc {
  (source: string, subString: string): boolean
}
const mySearch: SearchFunc = (src, sub) => src.includes(sub)

// =================================================================
// 4. 类型别名 (Type Aliases)
// =================================================================

type ID = string | number // 定义一个通用 ID 类型
type Result = { success: boolean; data: any }
type Greeter = (name: string) => string

const greet: Greeter = (n) => `Hello, ${n}`

// =================================================================
// 5. 类 (Classes)
// =================================================================

class Animal {
  // 属性简写：在构造函数参数前使用 public/private/protected
  constructor(public name: string) {}

  // 方法
  public move(distance: number = 0) {
    console.log(`${this.name} moved ${distance}m.`)
  }

  // 受保护的方法，子类可访问
  protected makeSound(sound: string) {
    console.log(`${this.name} says ${sound}`)
  }
}

class Dog extends Animal {
  constructor(name: string) {
    super(name)
  }

  bark() {
    // this.makeSound("woof"); // 继承自 Animal
  }

  // 属性访问器 (Getter/Setter)
  private _age: number = 0
  get age(): number {
    return this._age
  }
  set age(newAge: number) {
    if (newAge >= 0) {
      this._age = newAge
    }
  }
}

const myDog = new Dog('Buddy')
myDog.age = 5 // 调用 setter

// =================================================================
// 6. 泛型 (Generics)
// =================================================================

// 泛型函数：在函数签名中使用类型变量 T
function identity<T>(arg: T): T {
  return arg
}

const resultS = identity<string>('my string') // 显式指定类型
const resultN = identity(123) // 类型推断为 number

// 泛型接口
interface GenericIdentityFn<T> {
  (arg: T): T
}

// 泛型类
class GenericNumber<T> {
  zeroValue: T
  add: (x: T, y: T) => T

  constructor(zero: T, adder: (x: T, y: T) => T) {
    this.zeroValue = zero
    this.add = adder
  }
}

// 泛型约束 (Generic Constraints): 确保 T 拥有 length 属性
interface Lengthwise {
  length: number
}
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length) // OK, 因为 T 至少实现了 Lengthwise
  return arg
}
loggingIdentity([1, 2])

// =================================================================
// 7. 模块 (Modules)
// =================================================================

// 导出：使其可被其他文件使用
export const PI = 3.14159

export interface User {
  id: ID
  name: string
}

// 导入：在另一个文件 (例如 main.ts) 中
// import { PI, User } from './typescript-syntax-showcase';

// =================================================================
// 8. 装饰器 (Decorators)
// =================================================================
// 装饰器是实验性特性，需要设置 "experimentalDecorators": true

function logClass(constructor: Function) {
  console.log(`Class ${constructor.name} created`)
}

@logClass
class DecoratorExample {
  // ...
}

// =================================================================
// 9. 类型断言 (Type Assertions)
// =================================================================

// 方式一：使用 'as' 关键字 (推荐)
let someValue: any = 'this is a string'
let strLength: number = (someValue as string).length

// 方式二：使用尖括号 (在 JSX 中不推荐)
// let strLength2: number = (<string>someValue).length;

// =================================================================
// 10. 映射类型 (Mapped Types)
// =================================================================

// Utility Types (内置映射类型示例)

// 使得 T 的所有属性都变为可选
type PartialPerson = Partial<Point> // { x?: number; y?: number; z?: number; ... }

// 使得 T 的所有属性都变为只读
type ReadonlyPerson = Readonly<Point> // { readonly x: number; readonly y: number; ... }

// 从 T 中选取 K 属性
type OnlyX = Pick<Point, 'x'> // { x: number }

// 自定义映射类型: 使得所有属性都变为可空
type Nullable<T> = {
  [P in keyof T]: T[P] | null
}
type NullablePoint = Nullable<Point> // { x: number | null; y: number | null; ... }

// =================================================================
// 11. 条件类型 (Conditional Types)
// =================================================================

// 示例：如果 T 是 string，则结果是 number，否则是 boolean
type TypeResolver<T> = T extends string ? number : boolean

type R1 = TypeResolver<string> // number
type R2 = TypeResolver<number> // boolean

// 内置条件类型示例：
// 从 T 中排除可赋值给 U 的类型
type NonString = Exclude<string | number | boolean, string> // number | boolean

// =================================================================
// 12. 字面量类型 (Literal Types)
// =================================================================

type Direction = 'north' | 'south' | 'east' | 'west' // 只能是这四个字符串之一
let dir: Direction = 'north'
// dir = "up"; // Error

function move(d: Direction): void {
  /* ... */
}
```
